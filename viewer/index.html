<!DOCTYPE html>
<canvas id=cnv width=600 height=600></canvas>

<script id="vshader" type="x-shader/x-vertex">

    uniform mat4 u_ProjectionMatrix;

    attribute vec3 vNormal;
    attribute vec4 vTexCoord;
    attribute vec4 vPosition;

    varying vec2 v_texCoord;

    void main()
    {
        gl_Position = u_ProjectionMatrix * vPosition + vec4(vNormal * 0.00000001, 0.0);
        v_texCoord = vTexCoord.st;
    }

</script>

<script id="fshader" type="x-shader/x-fragment">

    precision mediump float;


	uniform float angle;

    varying vec2 v_texCoord;

	const vec3 sky_color = vec3(0.7, 0.8, 1.0) * 0.2;
	const vec3 sky_direction = vec3(0.0, 1.0, 0.0);

	float sdf2(vec3 pos) {
		vec3 v0 = pos;
		vec3 v1 = vec3(0.9553365, 0.29552022, 0.0);
		vec3 v2 = vec3(-0.29552022, 0.9553365, 0.0);
		vec3 v3 = vec3(0.0, 0.0, 1.0);
		mat3 v4 = mat3(v1, v2, v3);
		vec3 v5 = v4 * v0;
		float v6 = length(v5);
		float v7 = v6 - 0.2;
		vec3 v8 = vec3(-0.15, 0.1, 0.0);
		vec3 v9 = v5 - v8;
		vec3 v10 = vec3(-0.120000005, -0.120000005, -0.120000005);
		vec3 v11 = vec3(0.120000005, 0.120000005, 0.120000005);
		vec3 v12 = clamp(v9, v10, v11);
		vec3 v13 = v9 - v12;
		float v14 = length(v13);
		float v15 = v14 - 3.0e-2;
		float v16 = v15 - v7;
		float v17 = 0.5 * v16;
		float v18 = v17 / 3.0e-2;
		float v19 = 0.5 + v18;
		float v20 = clamp(v19, 0.0, 1.0);
		float v21 = mix(v15, v7, v20);
		float v22 = 3.0e-2 * v20;
		float v23 = 1.0 - v20;
		float v24 = v22 * v23;
		float v25 = v21 - v24;
		return v25;
	}

	float sdf1(vec3 pos) {

		vec3 v0 = pos;
		vec3 v1 = vec3(0.9553365, 0.29552022, 0.0);
		vec3 v2 = vec3(-0.29552022, 0.9553365, 0.0);
		vec3 v3 = vec3(0.0, 0.0, 1.0);
		mat3 v4 = mat3(v1, v2, v3);
		vec3 v5 = v4 * v0;
		float v6 = length(v5);
		float v7 = v6 - 0.2;
		vec3 v8 = vec3(-0.15, 0.1, 0.0);
		vec3 v9 = v5 - v8;
		vec3 v10 = vec3(-0.120000005, -0.120000005, -0.120000005);
		vec3 v11 = vec3(0.120000005, 0.120000005, 0.120000005);
		vec3 v12 = clamp(v9, v10, v11);
		vec3 v13 = v9 - v12;
		float v14 = length(v13);
		float v15 = v14 - 3.0e-2;
		float v16 = max(v7, v15);

		return v16;

	}

	float sdf(vec3 pos) {
		return sdf2(pos);
	}

	vec4 raymarch(vec3 dir, mat3 transform) {

		vec3 pos = vec3(0.0, 0.0, -1.0);
		for (int i = 0; i < 300; ++i) {
			float dist = sdf(transform * pos);
			pos = pos + dir * dist;
		}

		float alpha = sdf(transform * pos) < 0.0001 ? 1.0 : 0.0;
		return vec4(pos, alpha);
	}

	vec3 compute_normal(vec3 pos, mat3 transform) {
		const float delta = 0.001;
		vec3 offset = vec3(
			sdf(transform * (pos + vec3(delta, 0.0, 0.0))) - sdf(transform * (pos - vec3(delta, 0.0, 0.0))),
			sdf(transform * (pos + vec3(0.0, delta, 0.0))) - sdf(transform * (pos - vec3(0.0, delta, 0.0))),
			sdf(transform * (pos + vec3(0.0, 0.0, delta))) - sdf(transform * (pos - vec3(0.0, 0.0, delta))));
		return normalize(offset);
	}

	vec3 linear_to_gamma(vec3 color) {
		float level = 1.0 / 2.2;
		return vec3(
			pow(color.x, level),
			pow(color.y, level),
			pow(color.z, level));
	}

	vec3 gamma_to_linear(vec3 color) {
		float level = 2.2;
		return vec3(
			pow(color.x, level),
			pow(color.y, level),
			pow(color.z, level));
	}

	float blinn_phong(vec3 n, vec3 l, vec3 v, float exponent) {
		vec3 h = normalize(l + v);
		float normalization = (exponent + 1.0) * 0.15915494309;
		float specular_intensity = pow(max(dot(n, h), 0.0), exponent);
		return specular_intensity * normalization;
	}

	float lambert(vec3 n, vec3 l) {
		return max(dot(n, l), 0.0) * 0.31830988618;
	}

	float wide_lambert(vec3 n, vec3 l) {
		return dot(n, l) * 0.5 + 0.5;
	}

	float schlick(vec3 n, vec3 v) {
		float curve = pow(1.0 - dot(n, v), 5.0);
		float base = 0.04;
		return mix(base, 1.0, curve);
	}

	vec3 shade(vec3 n, vec3 v) {

		vec3 sky_power = 1.0 * gamma_to_linear(sky_color);
		vec3 sky_diffuse = sky_power * wide_lambert(n, sky_direction);
		vec3 sky_specular = sky_power * 1.0;

		vec3 lamp1_dir = normalize(vec3(1.0, 0.5, -0.3));
		vec3 lamp1_color = vec3(0.96, 0.83, 0.51) * 0.0 + 1.0;
		vec3 lamp1_power = 10.0 * gamma_to_linear(lamp1_color);
		vec3 lamp1_diffuse = lamp1_power * vec3(lambert(n, lamp1_dir));
		vec3 lamp1_specular = lamp1_power * vec3(blinn_phong(n, lamp1_dir, v, 34.0));

		vec3 lamp2_dir = normalize(vec3(-1.0, 0.1, -0.2));
		vec3 lamp2_color = vec3(0.96, 0.83, 0.51);
		vec3 lamp2_power = 0.2 * gamma_to_linear(lamp2_color);
		vec3 lamp2_diffuse = lamp2_power * vec3(wide_lambert(n, lamp2_dir));
		vec3 lamp2_specular = lamp2_power * vec3(blinn_phong(n, lamp2_dir, v, 8.0));

		vec3 lamp3_dir = normalize(vec3(-0.4, -0.1, 0.3));
		vec3 lamp3_color = vec3(0.2, 0.7, 0.5);
		vec3 lamp3_power = 0.5 * gamma_to_linear(lamp3_color);
		vec3 lamp3_diffuse = lamp3_power * vec3(lambert(n, lamp3_dir));
		vec3 lamp3_specular = lamp3_power * vec3(blinn_phong(n, lamp3_dir, v, 15.0));

		float fresnel = schlick(n, v);

		vec3 color = vec3(1.0, 0.8, 0.3);
		vec3 albedo = gamma_to_linear(color);
		vec3 diffuse = albedo * (lamp1_diffuse + lamp2_diffuse + lamp3_diffuse + sky_diffuse);

		vec3 specular = lamp1_specular + lamp2_specular + lamp3_specular + 0.6 * sky_specular;

		return mix(diffuse, specular, fresnel);
	}

    void main() {
		float ca = cos(angle);
		float sa = sin(angle);
		mat3 transform = mat3(
			ca, 0, -sa,
			 0, 1,   0,
			sa, 0,  ca
		);

		vec2 rectCoord = (v_texCoord.st * 2.0 - 1.0) * 0.7;

		vec3 v = -normalize(vec3(rectCoord, 1.0));

		vec4 res = raymarch(-v, transform);
		if (res.a < 0.5) {
			gl_FragColor = vec4(sky_color, 1.0);
		} else {
			vec3 n = compute_normal(res.xyz, transform);
			vec3 light = shade(n, v);
			vec3 tonemapped = light / (light + 1.0);
			gl_FragColor = vec4(linear_to_gamma(tonemapped), 1.0);
			// gl_FragColor = vec4(n*0.5+0.5, 1.0);
		}
    }

</script>


<script src=J3DI.js></script>
<script src=J3DIMath.js></script>
<script src=webgl-utils.js></script>
<script src=main.js></script>
