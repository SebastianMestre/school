<!DOCTYPE html>
<canvas id=cnv width=600 height=600></canvas>

<script id="vshader" type="x-shader/x-vertex">

    uniform mat4 u_ProjectionMatrix;

    attribute vec3 vNormal;
    attribute vec4 vTexCoord;
    attribute vec4 vPosition;

    varying vec2 v_texCoord;

    void main()
    {
        gl_Position = u_ProjectionMatrix * vPosition + vec4(vNormal * 0.00000001, 0.0);
        v_texCoord = vTexCoord.st;
    }

</script>

<script id="fshader" type="x-shader/x-fragment">

    precision mediump float;


	uniform float angle;

    varying vec2 v_texCoord;

	const vec3 sky_color = vec3(0.7, 0.8, 1.0) * 0.2;
	const vec3 sky_direction = vec3(0.0, 1.0, 0.0);

	float sdf2(vec3 pos) {
		vec3 v0 = pos;
vec3 v1 = vec3(-5.0e-2, -0.25, -9.999998e-3);
vec3 v2 = vec3(5.0e-2, 0.25, 9.999998e-3);
vec3 v3 = clamp(v0, v1, v2);
vec3 v4 = v0 - v3;
float v5 = length(v4);
float v6 = v5 - 5.0e-2;
vec3 v7 = vec3(-7.0e-2, 0.26, -1.5e-2);
vec3 v8 = v0 - v7;
float v9 = length(v8);
float v10 = v9 - 6.0e-2;
vec3 v11 = vec3(-2.0e-2, 0.29, -1.0e-2);
vec3 v12 = v0 - v11;
float v13 = length(v12);
float v14 = v13 - 7.0e-2;
vec3 v15 = vec3(4.5e-2, 0.28, -1.0e-2);
vec3 v16 = v0 - v15;
float v17 = length(v16);
float v18 = v17 - 7.0e-2;
vec3 v19 = vec3(0.1, 0.24, -2.0e-2);
vec3 v20 = v0 - v19;
float v21 = length(v20);
float v22 = v21 - 5.0e-2;
float v23 = min(v18, v22);
float v24 = min(v14, v23);
float v25 = min(v10, v24);
float v26 = v25 - v6;
float v27 = 0.5 * v26;
float v28 = v27 / 3.0e-2;
float v29 = 0.5 + v28;
float v30 = clamp(v29, 0.0, 1.0);
float v31 = mix(v25, v6, v30);
float v32 = 3.0e-2 * v30;
float v33 = 1.0 - v30;
float v34 = v32 * v33;
float v35 = v31 - v34;
vec3 v36 = vec3(0.0, 0.0, -5.0e-2);
vec3 v37 = v0 - v36;
vec3 v38 = vec3(-7.0e-2, 0.26, -1.0e-2);
vec3 v39 = v37 - v38;
float v40 = length(v39);
float v41 = v40 - 3.0e-2;
vec3 v42 = vec3(-2.0e-2, 0.29, -1.0e-2);
vec3 v43 = v37 - v42;
float v44 = length(v43);
float v45 = v44 - 3.0e-2;
vec3 v46 = vec3(4.5e-2, 0.28, -1.0e-2);
vec3 v47 = v37 - v46;
float v48 = length(v47);
float v49 = v48 - 3.0e-2;
vec3 v50 = vec3(0.1, 0.24, -6.0e-3);
vec3 v51 = v37 - v50;
float v52 = length(v51);
float v53 = v52 - 3.0e-2;
float v54 = min(v49, v53);
float v55 = min(v45, v54);
float v56 = min(v41, v55);
vec3 v57 = vec3(0.0, 0.2, -1.0e-2);
vec3 v58 = v0 - v57;
float v59 = length(v58);
float v60 = v59 - 7.0e-2;
vec3 v61 = vec3(-4.0e-2, -4.0e-2, -2.5e-2);
vec3 v62 = v58 - v61;
float v63 = length(v62);
float v64 = v63 - 4.0e-2;
vec3 v65 = vec3(4.0e-2, -4.0e-2, -2.5e-2);
vec3 v66 = v58 - v65;
float v67 = length(v66);
float v68 = v67 - 4.0e-2;
float v69 = min(v64, v68);
float v70 = v69 - v60;
float v71 = 0.5 * v70;
float v72 = v71 / 2.0e-2;
float v73 = 0.5 + v72;
float v74 = clamp(v73, 0.0, 1.0);
float v75 = mix(v69, v60, v74);
float v76 = 2.0e-2 * v74;
float v77 = 1.0 - v74;
float v78 = v76 * v77;
float v79 = v75 - v78;
float v80 = min(v56, v79);
float v81 = min(v35, v80);
return v81;
	}

	float sdf(vec3 pos) {
		return sdf2(pos);
	}

	vec4 raymarch(vec3 dir, mat3 transform) {

		vec3 pos = vec3(0.0, 0.0, -1.0);
		for (int i = 0; i < 128; ++i) {
			float dist = sdf(transform * pos);
			pos = pos + dir * dist;
		}

		float alpha = sdf(transform * pos) < 0.001 ? 1.0 : 0.0;
		return vec4(pos, alpha);
	}

	vec3 compute_normal(vec3 p, mat3 A) {
		const float h = 0.0001;
		const vec2 k = vec2(1.0, -1.0);
		return normalize(
			k.xyy * sdf(A * (p+k.xyy*h)) +
			k.yyx * sdf(A * (p+k.yyx*h)) +
			k.yxy * sdf(A * (p+k.yxy*h)) +
			k.xxx * sdf(A * (p+k.xxx*h)) );
	}

	vec3 linear_to_gamma(vec3 color) {
		float level = 1.0 / 2.2;
		return vec3(
			pow(color.x, level),
			pow(color.y, level),
			pow(color.z, level));
	}

	vec3 gamma_to_linear(vec3 color) {
		float level = 2.2;
		return vec3(
			pow(color.x, level),
			pow(color.y, level),
			pow(color.z, level));
	}

	float blinn_phong(vec3 n, vec3 l, vec3 v, float exponent) {
		vec3 h = normalize(l + v);
		float normalization = (exponent + 1.0) * 0.15915494309;
		float intensity = pow(max(dot(n, h), 0.0), exponent);
		return intensity * normalization;
	}

	float lambert(vec3 n, vec3 l) {
		return max(dot(n, l), 0.0) * 0.31830988618;
	}

	float wide_lambert(vec3 n, vec3 l) {
		return dot(n, l) * 0.5 + 0.5;
	}

	float schlick(vec3 n, vec3 v) {
		float curve = pow(1.0 - dot(n, v), 5.0);
		float base = 0.04;
		return mix(base, 1.0, curve);
	}

	vec3 shade(vec3 n, vec3 v) {

		vec3 sky_power = 1.0 * gamma_to_linear(sky_color);
		vec3 sky_diffuse = sky_power * wide_lambert(n, sky_direction);
		vec3 sky_specular = sky_power * 1.0;

		vec3 lamp1_dir = normalize(vec3(1.0, 0.5, -0.3));
		vec3 lamp1_color = vec3(0.96, 0.83, 0.51) * 0.0 + 1.0;
		vec3 lamp1_power = 10.0 * gamma_to_linear(lamp1_color);
		vec3 lamp1_diffuse = lamp1_power * vec3(lambert(n, lamp1_dir));
		vec3 lamp1_specular = lamp1_power * vec3(blinn_phong(n, lamp1_dir, v, 34.0));

		vec3 lamp2_dir = normalize(vec3(-1.0, 0.1, -0.2));
		vec3 lamp2_color = vec3(0.96, 0.83, 0.51);
		vec3 lamp2_power = 0.2 * gamma_to_linear(lamp2_color);
		vec3 lamp2_diffuse = lamp2_power * vec3(wide_lambert(n, lamp2_dir));
		vec3 lamp2_specular = lamp2_power * vec3(blinn_phong(n, lamp2_dir, v, 8.0));

		vec3 lamp3_dir = normalize(vec3(-0.4, -0.1, 0.3));
		vec3 lamp3_color = vec3(0.2, 0.7, 0.5);
		vec3 lamp3_power = 0.5 * gamma_to_linear(lamp3_color);
		vec3 lamp3_diffuse = lamp3_power * vec3(lambert(n, lamp3_dir));
		vec3 lamp3_specular = lamp3_power * vec3(blinn_phong(n, lamp3_dir, v, 15.0));

		float fresnel = schlick(n, v);

		vec3 color = vec3(1.0, 0.8, 0.3);
		vec3 albedo = gamma_to_linear(color);
		vec3 diffuse = albedo * (lamp1_diffuse + lamp2_diffuse + lamp3_diffuse + sky_diffuse);

		vec3 specular = lamp1_specular + lamp2_specular + lamp3_specular + 0.6 * sky_specular;

		return mix(diffuse, specular, fresnel);
	}

	void main() {
		float ca = cos(angle);
		float sa = sin(angle);
		mat3 transform = mat3(
			ca, 0, -sa,
			 0, 1,   0,
			sa, 0,  ca
		);

		vec2 rectCoord = (v_texCoord.st * 2.0 - 1.0) * 0.3 + vec2(0.0, +0.2);

		vec3 v = -normalize(vec3(rectCoord, 1.0));

		vec4 res = raymarch(-v, transform);
		if (res.a < 0.5) {
			gl_FragColor = vec4(sky_color, 1.0);
		} else {
			vec3 n = compute_normal(res.xyz, transform);
			vec3 light = shade(n, v);
			vec3 tonemapped = light / (light + 1.0);
			gl_FragColor = vec4(linear_to_gamma(tonemapped), 1.0);
			// gl_FragColor = vec4(linear_to_gamma(n*0.5+0.5), 1.0);
		}
	}

</script>


<script src=J3DI.js></script>
<script src=J3DIMath.js></script>
<script src=webgl-utils.js></script>
<script src=main.js></script>
